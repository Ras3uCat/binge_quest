import 'package:flutter/material.dart';
import '../../core/services/supabase_service.dart';
import '../models/content_cache_episode.dart';
import '../models/tmdb_content.dart';

/// Repository for episode cache operations.
/// Manages shared TMDB episode metadata across all users.
class ContentCacheEpisodesRepository {
  ContentCacheEpisodesRepository._();

  static final _client = SupabaseService.client;

  /// Get cached episode by TMDB show ID, season, and episode number.
  static Future<ContentCacheEpisode?> get(
    int tmdbId,
    int seasonNumber,
    int episodeNumber,
  ) async {
    final response = await _client
        .from('content_cache_episodes')
        .select()
        .eq('tmdb_id', tmdbId)
        .eq('season_number', seasonNumber)
        .eq('episode_number', episodeNumber)
        .maybeSingle();

    if (response == null) return null;
    return ContentCacheEpisode.fromJson(response);
  }

  /// Get cached episode by ID.
  static Future<ContentCacheEpisode?> getById(String id) async {
    final response = await _client
        .from('content_cache_episodes')
        .select()
        .eq('id', id)
        .maybeSingle();

    if (response == null) return null;
    return ContentCacheEpisode.fromJson(response);
  }

  /// Get all cached episodes for a season.
  static Future<List<ContentCacheEpisode>> getSeasonEpisodes(
    int tmdbId,
    int seasonNumber,
  ) async {
    final response = await _client
        .from('content_cache_episodes')
        .select()
        .eq('tmdb_id', tmdbId)
        .eq('season_number', seasonNumber)
        .order('episode_number', ascending: true);

    return (response as List)
        .map((json) => ContentCacheEpisode.fromJson(json))
        .toList();
  }

  /// Get all cached episodes for a TV show.
  static Future<List<ContentCacheEpisode>> getAllEpisodesForShow(
    int tmdbId,
  ) async {
    try {
      final response = await _client
          .from('content_cache_episodes')
          .select()
          .eq('tmdb_id', tmdbId)
          .order('season_number', ascending: true)
          .order('episode_number', ascending: true);

      return (response as List)
          .map((json) => ContentCacheEpisode.fromJson(json))
          .toList();
    } catch (e) {
      debugPrint('Error getting episodes for show $tmdbId: $e');
      return [];
    }
  }

  /// Check if episode exists in cache.
  static Future<bool> exists(
    int tmdbId,
    int seasonNumber,
    int episodeNumber,
  ) async {
    final response = await _client
        .from('content_cache_episodes')
        .select('id')
        .eq('tmdb_id', tmdbId)
        .eq('season_number', seasonNumber)
        .eq('episode_number', episodeNumber)
        .maybeSingle();

    return response != null;
  }

  /// Insert or update episode in cache.
  static Future<ContentCacheEpisode> upsert(ContentCacheEpisode episode) async {
    final response = await _client
        .from('content_cache_episodes')
        .upsert(episode.toInsertJson())
        .select()
        .single();

    return ContentCacheEpisode.fromJson(response);
  }

  /// Insert episode only if it doesn't exist.
  /// Returns existing episode if already cached, otherwise inserts and returns new.
  static Future<ContentCacheEpisode> ensureExists(
    ContentCacheEpisode episode,
  ) async {
    final existing = await get(
      episode.tmdbId,
      episode.seasonNumber,
      episode.episodeNumber,
    );
    if (existing != null) return existing;

    return upsert(episode);
  }

  /// Batch insert multiple episodes.
  /// Uses upsert with conflict handling on the unique constraint.
  static Future<List<ContentCacheEpisode>> batchInsert(
    List<ContentCacheEpisode> episodes,
  ) async {
    if (episodes.isEmpty) return [];

    try {
      final response = await _client
          .from('content_cache_episodes')
          .upsert(
            episodes.map((e) => e.toInsertJson()).toList(),
            onConflict: 'tmdb_id,season_number,episode_number',
          )
          .select();

      return (response as List)
          .map((json) => ContentCacheEpisode.fromJson(json))
          .toList();
    } catch (e) {
      debugPrint('Episode batch insert error: $e');
      rethrow;
    }
  }

  /// Create ContentCacheEpisode from TMDB episode data.
  static ContentCacheEpisode fromTmdbEpisode(
    int showTmdbId,
    TmdbEpisode episode,
  ) {
    return ContentCacheEpisode(
      id: '', // Will be generated by database
      tmdbId: showTmdbId,
      seasonNumber: episode.seasonNumber,
      episodeNumber: episode.episodeNumber,
      episodeName: episode.name,
      episodeOverview: episode.overview,
      runtimeMinutes: episode.runtime ?? 0,
      airDate: episode.airDate != null && episode.airDate!.isNotEmpty
          ? DateTime.tryParse(episode.airDate!)
          : null,
      stillPath: episode.stillPath,
      voteAverage: episode.voteAverage,
      createdAt: DateTime.now(),
      updatedAt: DateTime.now(),
    );
  }

  /// Get stale episode entries that need refresh.
  static Future<List<ContentCacheEpisode>> getStaleEntries({
    int staleDays = 30,
    int limit = 100,
  }) async {
    final staleDate = DateTime.now().subtract(Duration(days: staleDays));

    final response = await _client
        .from('content_cache_episodes')
        .select()
        .lt('updated_at', staleDate.toIso8601String())
        .order('updated_at', ascending: true)
        .limit(limit);

    return (response as List)
        .map((json) => ContentCacheEpisode.fromJson(json))
        .toList();
  }
}
