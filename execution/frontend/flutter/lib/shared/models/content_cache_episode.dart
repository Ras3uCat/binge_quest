import 'package:intl/intl.dart';

/// Cached episode metadata from TMDB.
/// One row per unique (tmdb_id, season_number, episode_number) combination.
/// Shared across all users.
class ContentCacheEpisode {
  final String id;
  final int tmdbId; // TV show's TMDB ID
  final int seasonNumber;
  final int episodeNumber;
  final String? episodeName;
  final String? episodeOverview;
  final int runtimeMinutes;
  final DateTime? airDate;
  final String? stillPath;
  final double? voteAverage;
  final DateTime createdAt;
  final DateTime updatedAt;

  bool get hasAired => airDate != null && airDate!.isBefore(DateTime.now());
  bool get isUpcoming => airDate != null && airDate!.isAfter(DateTime.now());

  String get airDateDisplay {
    if (airDate == null) return 'TBA';
    final formatter = DateFormat.yMMMd();
    if (isUpcoming) return 'Airs: ${formatter.format(airDate!)}';
    return 'Aired: ${formatter.format(airDate!)}';
  }

  const ContentCacheEpisode({
    required this.id,
    required this.tmdbId,
    required this.seasonNumber,
    required this.episodeNumber,
    this.episodeName,
    this.episodeOverview,
    required this.runtimeMinutes,
    this.airDate,
    this.stillPath,
    this.voteAverage,
    required this.createdAt,
    required this.updatedAt,
  });

  /// Formatted episode code (e.g., "S01E05").
  String get episodeCode {
    final s = seasonNumber.toString().padLeft(2, '0');
    final e = episodeNumber.toString().padLeft(2, '0');
    return 'S${s}E$e';
  }

  /// Display title: either episode name or generic "Episode X".
  String get displayTitle {
    if (episodeName != null && episodeName!.isNotEmpty) {
      return episodeName!;
    }
    return 'Episode $episodeNumber';
  }

  factory ContentCacheEpisode.fromJson(Map<String, dynamic> json) {
    return ContentCacheEpisode(
      id: json['id'] as String,
      tmdbId: json['tmdb_id'] as int,
      seasonNumber: json['season_number'] as int,
      episodeNumber: json['episode_number'] as int,
      episodeName: json['episode_name'] as String?,
      episodeOverview: json['episode_overview'] as String?,
      runtimeMinutes: json['runtime_minutes'] as int? ?? 0,
      airDate: json['air_date'] != null
          ? DateTime.tryParse(json['air_date'] as String)
          : null,
      stillPath: json['still_path'] as String?,
      voteAverage: (json['vote_average'] as num?)?.toDouble(),
      createdAt: json['created_at'] != null
          ? DateTime.parse(json['created_at'] as String)
          : DateTime.now(),
      updatedAt: json['updated_at'] != null
          ? DateTime.parse(json['updated_at'] as String)
          : DateTime.now(),
    );
  }

  /// Create ContentCacheEpisode from TMDB episode JSON.
  factory ContentCacheEpisode.fromTmdbJson(
    int showTmdbId,
    int seasonNumber,
    Map<String, dynamic> json,
  ) {
    return ContentCacheEpisode(
      id: '', // Will be generated by database
      tmdbId: showTmdbId,
      seasonNumber: seasonNumber,
      episodeNumber: json['episode_number'] as int,
      episodeName: json['name'] as String?,
      episodeOverview: json['overview'] as String?,
      runtimeMinutes: json['runtime'] as int? ?? 0,
      airDate:
          json['air_date'] != null && (json['air_date'] as String).isNotEmpty
          ? DateTime.tryParse(json['air_date'] as String)
          : null,
      stillPath: json['still_path'] as String?,
      voteAverage: (json['vote_average'] as num?)?.toDouble(),
      createdAt: DateTime.now(),
      updatedAt: DateTime.now(),
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'tmdb_id': tmdbId,
      'season_number': seasonNumber,
      'episode_number': episodeNumber,
      'episode_name': episodeName,
      'episode_overview': episodeOverview,
      'runtime_minutes': runtimeMinutes,
      'air_date': airDate?.toIso8601String().split('T').first,
      'still_path': stillPath,
      'vote_average': voteAverage,
    };
  }

  /// Convert to JSON for insert (without id, timestamps are auto-generated).
  Map<String, dynamic> toInsertJson() {
    return {
      'tmdb_id': tmdbId,
      'season_number': seasonNumber,
      'episode_number': episodeNumber,
      'episode_name': episodeName,
      'episode_overview': episodeOverview,
      'runtime_minutes': runtimeMinutes,
      'air_date': airDate?.toIso8601String().split('T').first,
      'still_path': stillPath,
      'vote_average': voteAverage,
    };
  }

  ContentCacheEpisode copyWith({
    String? id,
    int? tmdbId,
    int? seasonNumber,
    int? episodeNumber,
    String? episodeName,
    String? episodeOverview,
    int? runtimeMinutes,
    DateTime? airDate,
    String? stillPath,
    double? voteAverage,
    DateTime? createdAt,
    DateTime? updatedAt,
  }) {
    return ContentCacheEpisode(
      id: id ?? this.id,
      tmdbId: tmdbId ?? this.tmdbId,
      seasonNumber: seasonNumber ?? this.seasonNumber,
      episodeNumber: episodeNumber ?? this.episodeNumber,
      episodeName: episodeName ?? this.episodeName,
      episodeOverview: episodeOverview ?? this.episodeOverview,
      runtimeMinutes: runtimeMinutes ?? this.runtimeMinutes,
      airDate: airDate ?? this.airDate,
      stillPath: stillPath ?? this.stillPath,
      voteAverage: voteAverage ?? this.voteAverage,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
    );
  }

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ContentCacheEpisode &&
          runtimeType == other.runtimeType &&
          tmdbId == other.tmdbId &&
          seasonNumber == other.seasonNumber &&
          episodeNumber == other.episodeNumber;

  @override
  int get hashCode => Object.hash(tmdbId, seasonNumber, episodeNumber);
}
